type NotInterested @model @auth(rules: [{ allow: public }]) {
  id: ID!
  user: User @connection
  post: Post @connection
  targetUser: User @connection
  notInterestedUserId: ID
  notInterestedPostId: ID
  notInterestedTargetUserId: ID
  type: String
}

type Report
  @model
  @auth(rules: [{ allow: public }])
  @key(
    name: "reportTargetUserId-index"
    fields: ["reportTargetUserId"]
    queryField: "reportTargetUserId"
  )
  @key(
    name: "reportUserId-index"
    fields: ["reportUserId"]
    queryField: "reportUserId"
  )
  @key(
    name: "reportPostId-index"
    fields: ["reportPostId"]
    queryField: "reportPostId"
  ) {
  id: ID!
  reason: String
  description: String
  status: String
  user: User @connection
  post: Post @connection
  type: String
  result: String
  reportUserId: ID
  reportPostId: ID
  targetUser: User @connection
  reportTargetUserId: ID
}

type View
  @model
  @auth(rules: [{ allow: public }])
  @key(
    name: "viewPostId-index"
    fields: ["viewPostId"]
    queryField: "viewPostId"
  )
  @key(
    name: "viewUserId-index"
    fields: ["viewUserId"]
    queryField: "viewUserId"
  )
  @key(
    name: "viewPostId-viewUserId-index"
    fields: ["viewPostId", "viewUserId"]
    queryField: "viewByPostIdUserId"
  ) {
  id: ID!
  post: Post @connection
  user: User @connection
  viewUserId: ID!
  viewPostId: ID!
}

type Share @model @auth(rules: [{ allow: public }]) {
  id: ID!
  to: String
  user: User @connection
  post: Post @connection
  shareUserId: ID!
  sharePostId: ID!
}

type Comment @model @auth(rules: [{ allow: public }]) {
  id: ID!
  user: User @connection
  post: Post @connection
  text: String
  commentUserId: ID!
  commentPostId: ID!
}

type Like
  @model
  @auth(rules: [{ allow: public }])
  @key(
    name: "likePostId-likeUserId-index"
    fields: ["likePostId", "likeUserId"]
    queryField: "likeByPostIdUserId"
  )
  @key(
    name: "likePostId-index"
    fields: ["likePostId"]
    queryField: "likeByPostId"
  )
  @key(
    name: "likeUserId-index"
    fields: ["likeUserId"]
    queryField: "likeByUserId"
  ) {
  id: ID!
  user: User @connection
  post: Post @connection
  likeUserId: ID!
  likePostId: ID!
  value: Boolean
}

type Post
  @model
  @auth(rules: [{ allow: public }])
  @key(
    name: "postUserId-index"
    fields: ["postUserId"]
    queryField: "postByUserId"
  ) {
  id: ID!
  text: String
  user: User @connection
  music: Music @connection
  attachments: AWSJSON
  likeCount: Int
  commentCount: Int
  shareCount: Int
  postUserId: ID
  viewCount: Int
  isDeleted: Boolean
  isBlocked: Boolean
}

type Music @model @auth(rules: [{ allow: public }]) {
  id: ID!
  url: String
  img: String
}

type User @model @auth(rules: [{ allow: public }]) {
  id: ID!
  nickname: String
  portrait: String
  bio: String
  birth: AWSDate
  gender: Int
  city: String
  profession: String
  username: String
  email: String
  phoneNumber: String
  authStatus: String
  isDeleted: Boolean
  isBlocked: Boolean
}

type PostEx {
  id: ID!
  text: String
  user: User
  music: Music
  attachments: AWSJSON
  likeCount: Int
  commentCount: Int
  shareCount: Int
  viewCount: Int
  isLiked: Like
  isDeleted: Boolean
  isBlocked: Boolean
}

type ModelPostExConnection @aws_api_key @aws_iam {
  items: [PostEx]
  nextToken: String
  startedAt: AWSTimestamp
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelViewConditionInput {
  likePostId: ModelStringInput
  likeUserId: ModelStringInput
  and: [ModelViewConditionInput]
  or: [ModelViewConditionInput]
  not: ModelViewConditionInput
}

input CreateLikeInput {
  id: ID
  likeUserId: ID!
  likePostId: ID!
  value: Boolean
  _version: Int
}

input CreateViewInput {
  id: ID
  _version: Int
  viewPostId: ID
  viewUserId: ID
}

input UpsertLikeInput {
  id: ID
  value: Boolean
  _version: Int
  likeUserId: ID
  likePostId: ID
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelLikeConditionInput {
  value: ModelBooleanInput
  likePostId: ModelStringInput
  likeUserId: ModelStringInput
  and: [ModelLikeConditionInput]
  or: [ModelLikeConditionInput]
  not: ModelLikeConditionInput
}

input AddPostInput {
  likeCount: Int
  commentCount: Int
  shareCount: Int
  viewCount: Int
}

input UpdatePostInput {
  id: ID!
  text: String
  attachments: AWSJSON
  likeCount: Int
  commentCount: Int
  shareCount: Int
  _version: Int
  postUserId: ID
  postMusicId: ID
}

input ModelPostConditionInput {
  text: ModelStringInput
  attachments: ModelStringInput
  likeCount: ModelIntInput
  commentCount: ModelIntInput
  shareCount: ModelIntInput
  postUserId: ModelStringInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelPostFilterInput {
  id: ModelIDInput
  text: ModelStringInput
  attachments: ModelStringInput
  likeCount: ModelIntInput
  commentCount: ModelIntInput
  shareCount: ModelIntInput
  postUserId: ModelStringInput
  viewCount: ModelIntInput
  isDeleted: ModelBooleanInput
  isBlocked: ModelBooleanInput
  and: [ModelPostFilterInput]
  or: [ModelPostFilterInput]
  not: ModelPostFilterInput
}

input TranscribeAudioPartInput {
  audioUrl: String
}

type TranscribeAudioPartResult {
  subtitleFileUri: String
}

type Mutation {
  updatePostEx(
    input: UpdatePostInput!
    add: AddPostInput
    condition: ModelPostConditionInput
  ): Post @aws_api_key @aws_iam
  updatePostPowered(
    input: UpdatePostInput!
    add: AddPostInput
    condition: ModelPostConditionInput
  ): Post @aws_api_key @aws_iam
  likePost(input: CreateLikeInput!, condition: ModelLikeConditionInput): Like
    @aws_api_key
    @aws_iam
    @function(name: "likePost-${env}")
  viewPost(input: CreateViewInput!, condition: ModelViewConditionInput): View
    @aws_api_key
    @aws_iam
    @function(name: "viewPost-${env}")
  transcribeAudioPart(
    input: TranscribeAudioPartInput!
  ): TranscribeAudioPartResult
    @aws_api_key
    @aws_iam
    @function(name: "transcribeAudioPart-${env}")
}

type Query {
  listPostExs(
    filter: ModelPostFilterInput
    userId: ID!
    limit: Int
    nextToken: String
  ): ModelPostExConnection @function(name: "listPostExs-${env}")
}
