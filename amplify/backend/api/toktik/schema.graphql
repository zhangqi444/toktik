type View @model @auth(rules: [{allow: public}]) {
  id: ID!
  post: Post @connection
  user: User @connection
}

type Share @model @auth(rules: [{allow: public}]) {
  id: ID!
  to: String
  user: User @connection
  post: Post @connection
}

type Comment @model @auth(rules: [{allow: public}]) {
  id: ID!
  user: User @connection
  post: Post @connection
  text: String
}

type Like @model @auth(rules: [{allow: public}]) {
  id: ID!
  user: User @connection
  post: Post @connection
  value: Boolean
}

type Post @model @auth(rules: [{allow: public}]) {
  id: ID!
  text: String
  user: User @connection
  music: Music @connection
  attachments: AWSJSON
  likeCount: Int
  commentCount: Int
  shareCount: Int
  viewCount: Int
}

type Music @model @auth(rules: [{allow: public}]) {
  id: ID!
  url: String
  img: String
}

type User @model @auth(rules: [{allow: public}]) {
  id: ID!
  nickname: String
  portrait: String
  bio: String
  birth: AWSDate
  gender: Int
  city: String
  profession: String
  username: String
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input UpsertLikeInput {
  id: ID
  value: Boolean
  _version: Int
  likeUserId: ID
  likePostId: ID
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelLikeConditionInput {
  value: ModelBooleanInput
  likePostId: ModelStringInput
  likeUserId: ModelStringInput
  and: [ModelLikeConditionInput]
  or: [ModelLikeConditionInput]
  not: ModelLikeConditionInput
}

input AddPostInput {
  likeCount: Int
  commentCount: Int
  shareCount: Int
  viewCount: Int
}

input UpdatePostInput {
  id: ID!
  text: String
  attachments: AWSJSON
  likeCount: Int
  commentCount: Int
  shareCount: Int
  _version: Int
  postUserId: ID
  postMusicId: ID
}

input ModelPostConditionInput {
  text: ModelStringInput
  attachments: ModelStringInput
  likeCount: ModelIntInput
  commentCount: ModelIntInput
  shareCount: ModelIntInput
  and: [ModelPostConditionInput]
  or: [ModelPostConditionInput]
  not: ModelPostConditionInput
}

type Mutation {
  upsertLikeDenormalized(input: UpsertLikeInput!, condition: ModelLikeConditionInput): Like @aws_api_key @aws_iam
  upsertLike(input: UpsertLikeInput!, condition: ModelLikeConditionInput): Like @aws_api_key
  updatePostEx(input: UpdatePostInput!, add: AddPostInput, condition: ModelPostConditionInput): Post @aws_api_key @aws_iam
}
 